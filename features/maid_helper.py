"""
Maid System Helper Functions
ƒê·ªÉ integrate maid buffs v√†o c√°c h·ªá th·ªëng game hi·ªán t·∫°i
"""
from typing import Dict, Optional, Tuple
from database.database import Database
from features.maid_database import MaidDatabase
from features.maid_config import MAID_TEMPLATES
from features.maid_monitoring import maid_monitor

class MaidBuffHelper:
    def __init__(self, db_path: str = "farm_bot.db"):
        self.db_path = db_path  # ‚≠ê Missing line!
        try:
            self.db = Database('farm_bot.db')
            self.maid_db = MaidDatabase(db_path)
        except Exception:
            # Fallback for testing environment
            self.db = None
            self.maid_db = None
    
    def get_user_maid_buffs(self, user_id: int) -> Dict[str, float]:
        """
        L·∫•y t·∫•t c·∫£ buff hi·ªán t·∫°i c·ªßa user t·ª´ maid active
        
        Returns:
            Dict v·ªõi key l√† buff_type v√† value l√† % buff
            VD: {"growth_speed": 25.5, "yield_boost": 15.0}
        """
        buffs = {
            "growth_speed": 0.0,
            "seed_discount": 0.0,
            "yield_boost": 0.0,
            "sell_price": 0.0
        }
        
        try:
            # üéÄ Direct implementation - exactly like working inline test
            import sqlite3
            import json
            
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT maid_id, buff_values 
                FROM user_maids_v2 
                WHERE user_id = ? AND is_active = 1
            """, (user_id,))
            
            result = cursor.fetchone()
            if not result:
                conn.close()
                return buffs
            
            maid_id, buff_values_json = result
            
            if buff_values_json:
                try:
                    buff_list = json.loads(buff_values_json)
                    
                    for buff_data in buff_list:
                        buff_type = buff_data.get('type') or buff_data.get('buff_type')
                        buff_value = float(buff_data.get('value', 0.0))
                        
                        if buff_type and buff_type in buffs:
                            buffs[buff_type] += buff_value
                        
                except Exception as e:
                    pass  # Silent fail for now
            
            conn.close()
            
        except Exception as e:
            # Show the actual error instead of hiding it
            print(f"‚ùå maid_helper error for user {user_id}: {e}")
            import traceback
            traceback.print_exc()
            
            # Fallback to old system if V2 fails
            try:
                if self.maid_db:
                    active_maid = self.maid_db.get_active_maid(user_id)
                    if active_maid and hasattr(active_maid, 'buff_values'):
                        buff_values = active_maid.buff_values
                        if not hasattr(buff_values, '__await__'):
                            for buff in buff_values:
                                if hasattr(buff, 'buff_type') and buff.buff_type in buffs:
                                    buffs[buff.buff_type] += buff.value
            except Exception as fallback_error:
                print(f"‚ùå Fallback error: {fallback_error}")
        
        return buffs
    
    def apply_growth_speed_buff(self, user_id: int, base_growth_time: int) -> int:
        """
        Apply growth speed buff (gi·∫£m th·ªùi gian tr·ªìng c√¢y)
        
        Args:
            user_id: ID c·ªßa user
            base_growth_time: Th·ªùi gian sinh tr∆∞·ªüng g·ªëc (seconds)
            
        Returns:
            Th·ªùi gian sinh tr∆∞·ªüng sau khi apply buff
        """
        buffs = self.get_user_maid_buffs(user_id)
        growth_speed_buff = buffs.get("growth_speed", 0.0)
        
        # üõ°Ô∏è Cap buff ƒë·ªÉ tr√°nh exploit
        growth_speed_buff = max(0.0, min(growth_speed_buff, 80.0))  # Max 80% reduction
        
        if growth_speed_buff > 0:
            # Gi·∫£m th·ªùi gian theo % buff
            reduction = growth_speed_buff / 100.0
            new_time = int(base_growth_time * (1 - reduction))
            final_time = max(new_time, 60)  # T·ªëi thi·ªÉu 1 ph√∫t
            
            # üìä Log usage for monitoring
            maid_monitor.log_buff_usage(
                user_id, "growth_speed", growth_speed_buff,
                base_growth_time, final_time, "crop_growth"
            )
            
            return final_time
        
        return base_growth_time
    
    def apply_seed_discount_buff(self, user_id: int, base_seed_price: int) -> int:
        """
        Apply seed discount buff (gi·∫£m gi√° h·∫°t gi·ªëng)
        
        Args:
            user_id: ID c·ªßa user
            base_seed_price: Gi√° h·∫°t gi·ªëng g·ªëc
            
        Returns:
            Gi√° h·∫°t gi·ªëng sau khi apply buff
        """
        buffs = self.get_user_maid_buffs(user_id)
        seed_discount_buff = buffs.get("seed_discount", 0.0)
        
        # üõ°Ô∏è Cap buff ƒë·ªÉ tr√°nh exploit
        seed_discount_buff = max(0.0, min(seed_discount_buff, 90.0))  # Max 90% discount
        
        if seed_discount_buff > 0:
            # Gi·∫£m gi√° theo % buff
            discount = seed_discount_buff / 100.0
            new_price = int(base_seed_price * (1 - discount))
            return max(new_price, 1)  # T·ªëi thi·ªÉu 1 coin
        
        return base_seed_price
    
    def apply_yield_boost_buff(self, user_id: int, base_yield: int) -> int:
        """
        Apply yield boost buff (tƒÉng s·∫£n l∆∞·ª£ng)
        
        Args:
            user_id: ID c·ªßa user
            base_yield: S·∫£n l∆∞·ª£ng g·ªëc
            
        Returns:
            S·∫£n l∆∞·ª£ng sau khi apply buff
        """
        buffs = self.get_user_maid_buffs(user_id)
        yield_boost_buff = buffs.get("yield_boost", 0.0)
        
        # üõ°Ô∏è Cap buff ƒë·ªÉ tr√°nh exploit
        yield_boost_buff = max(0.0, min(yield_boost_buff, 200.0))  # Max 200% increase
        
        if yield_boost_buff > 0:
            # TƒÉng s·∫£n l∆∞·ª£ng theo % buff
            boost = yield_boost_buff / 100.0
            new_yield = int(base_yield * (1 + boost))
            return new_yield
        
        return base_yield
    
    def apply_sell_price_buff(self, user_id: int, base_sell_price: int) -> int:
        """
        Apply sell price buff (tƒÉng gi√° b√°n)
        
        Args:
            user_id: ID c·ªßa user
            base_sell_price: Gi√° b√°n g·ªëc
            
        Returns:
            Gi√° b√°n sau khi apply buff
        """
        buffs = self.get_user_maid_buffs(user_id)
        sell_price_buff = buffs.get("sell_price", 0.0)
        
        # üõ°Ô∏è Cap buff ƒë·ªÉ tr√°nh exploit
        sell_price_buff = max(0.0, min(sell_price_buff, 150.0))  # Max 150% increase
        
        if sell_price_buff > 0:
            # TƒÉng gi√° b√°n theo % buff
            boost = sell_price_buff / 100.0
            new_price = int(base_sell_price * (1 + boost))
            return new_price
        
        return base_sell_price
    
    def get_active_maid_info(self, user_id: int) -> Optional[Dict]:
        """
        L·∫•y th√¥ng tin maid active ƒë·ªÉ hi·ªÉn th·ªã
        
        Returns:
            Dict ch·ª©a th√¥ng tin maid ho·∫∑c None n·∫øu kh√¥ng c√≥
        """
        try:
            active_maid = self.maid_db.get_active_maid(user_id)
            if not active_maid:
                return None
            
            template = MAID_TEMPLATES.get(active_maid.maid_id)
            if not template:
                return None
            
            # Handle buff_values safely
            buffs_info = []
            try:
                buff_values = active_maid.buff_values
                if not hasattr(buff_values, '__await__'):
                    buffs_info = [
                        {
                            "type": buff.buff_type,
                            "value": buff.value,
                            "description": getattr(buff, 'description', '')
                        }
                        for buff in buff_values
                        if hasattr(buff, 'buff_type')
                    ]
            except (AttributeError, TypeError):
                pass
            
            return {
                "name": active_maid.custom_name or template["name"],
                "full_name": template.get("full_name", template["name"]),
                "emoji": template["emoji"],
                "rarity": template["rarity"],
                "buffs": buffs_info
            }
        except Exception:
            return None
    
    def get_buff_summary_text(self, user_id: int) -> str:
        """
        T·∫°o text summary ng·∫Øn g·ªçn v·ªÅ buffs hi·ªán t·∫°i
        
        Returns:
            String m√¥ t·∫£ buffs ho·∫∑c empty string n·∫øu kh√¥ng c√≥
        """
        buffs = self.get_user_maid_buffs(user_id)
        active_buffs = [(k, v) for k, v in buffs.items() if v > 0]
        
        if not active_buffs:
            return ""
        
        from features.maid_config import BUFF_TYPES
        
        buff_texts = []
        for buff_type, value in active_buffs:
            if buff_type in BUFF_TYPES:
                emoji = BUFF_TYPES[buff_type]["emoji"]
                buff_texts.append(f"{emoji}+{value}%")
        
        return " ".join(buff_texts)
    
    def calculate_all_farm_modifiers(self, user_id: int, 
                                   base_growth_time: int, 
                                   base_seed_price: int,
                                   base_yield: int, 
                                   base_sell_price: int) -> Dict[str, int]:
        """
        T√≠nh to√°n t·∫•t c·∫£ modifiers cho farming trong 1 l·∫ßn call
        
        Returns:
            Dict ch·ª©a t·∫•t c·∫£ gi√° tr·ªã ƒë√£ ƒë∆∞·ª£c modified
        """
        return {
            "growth_time": self.apply_growth_speed_buff(user_id, base_growth_time),
            "seed_price": self.apply_seed_discount_buff(user_id, base_seed_price),
            "yield": self.apply_yield_boost_buff(user_id, base_yield),
            "sell_price": self.apply_sell_price_buff(user_id, base_sell_price)
        }

# Global instance ƒë·ªÉ s·ª≠ d·ª•ng trong c√°c cogs kh√°c
maid_helper = MaidBuffHelper() 